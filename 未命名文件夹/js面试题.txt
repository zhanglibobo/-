事件冒泡、事件捕获、事件委托：
	1. 事件冒泡：当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window。
        (注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，
        就算传递了事件 也不会有什么表现 但事件确实传递了。)
	2. 事件捕获会从document开始触发，一级一级往下传递，依次触发，直到真正事件目标为止。
	3. 事件委托：js事件委托，其实是使用了冒泡的原理，从点击的元素开始，递归方式的向父元素传播事件，
		这样做的好处是对于大量要处理的元素，不必为每个元素都绑定事件，只需要在他们的父元素上绑定一次即可，提高性能。 
		还有一个好处就是可以处理动态插入dom中的元素，直接绑定的方式是不行的。就是事件目标自身不处理事件，
		而是把处理任务委托给其父元素或者祖先元素，甚至根元素事件委托很好地利用了"事件冒泡"。当点击子元素，根据"事件冒泡"，
		该子元素的父级元素捕获了该次点击事件，并触发自己的方法。
如何阻止事件冒泡？
	1. window.event.cancelBubble = true;IE特有的,谷歌支持,火狐不支持
	2. e.stopPropagation;谷歌火狐支持，IE不支持
	3. event,target == this
	4. jquery =》 return false
阻止默认事件：
	e.preventDefault()；jquery：return false;
new操作：
	1. 创建一个空的对象
	2. 将空对象的__proto__指向构造函数的prototype
	3. 改变this指向，将构造函数的this改为指向创建的空对象
	4. 对构造函数有返回值的判断；
		如果返回值是基本数据类型，会忽略返回值
		返回值为引用数据类型，new操作符无效
继承：继承是一种关系，继承的目的是为了数据共享
	ES5继承：
		实现继承的方法：
			1. 改变原型链指向。缺点：父类的属性在初始化的时候就已经固定了
			2.构造函数函数继承。缺点：无法继承方法
			3.组合继承
			4.拷贝继承
			5.Object.create(obj)
				创建一个新对象，使用现有的对象来提供新创建的对象的__proto__,参数是新创建对象的原型对象；es5
	ES6继承：
		class关键字：
			1.new.target，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数，
				如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined
			2.类的内部有get和set关键字，对于某个属性设置存取时的行为进行拦截
			3.注意点：
				类和模块内部，默认是严格模；
				不存在变量的提升；
				有name属性，.name获取类的名称；
				某个方法前加上*，就是Generator函数
				this的指向，默认指向类的实例，但是一旦单独使用该方法，就会报错，解决：在构造方法中绑定this或者使用箭头函数；
		super关键字：
			1.既可以当做函数，也可以当做对象使用
				1）作为函数使用，代表的是父类的构造函数，虽然代表的是父类的构造函数，但是返回的是子类的实例，
					即super内部的this指向的是子类的实例对象。子类中的this代表：父类.prototype.contructor.call(this)
				2）对象，
					普通方法：
						指向的是父类的原型对象，
						定义在父类实例上的属性或方法是无法通过super调用的，只能调用定义在原型对象上的属性或者方法。
						方法中的this指向的是子类的实例。
					静态方法：(方法前有static修饰，不会被实例继承，可以被子类继承，静态方法中的this指向的是类！！！)
						指向父类
						通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。
			2.使用super的时候，必须显示指定是作为函数还是作为对象使用，否则会报错
			3.对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字
		类的 prototype 属性和__proto__属性:
			Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
				1） 作为一个对象，子类（B）的原型（__proto__属性）是父类（A），
					子类的__proto__属性，表示构造函数的继承，总是指向父类
				2） 作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。
					子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性
		实例的__proto__属性：
			子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。
原型和原型链：
	原型：
		1.原型作用：相当于一个公共区域，构造函数的实例都可以访问原型
		2.每个实例对象中有__proto__，是原型对象，是不标准的，供浏览器使用。
			作用：实例对象调用方法和属性的时候，找不到就从__proto__指向的对象里找，一直到原型链的终点null
		3.每个构造函数有prototype，是标准的，供程序员使用。
			作用：存放共享数据的，供所有实例对象使用
	原型链：是一种关系,实例对象和原型对象之间的关系,关系是通过原型(__proto__)来联系的
垃圾回收机制
	作用：JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，
		垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
	变量的生命周期：
		1.当一个变量的生命周期结束之后它所指向的内存就应该被释放
		2. JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，
			此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。
	进行垃圾回收的两种方法：
		标记清除：当变量进入执行环境，将其标记为“进入环境”，当变量离开环境时标记为“离开环境”。
			垃圾收集器在运行的时候会把内存中的变量都加上标记，然后去掉环境中的变量及被环境变量所引用的变量（即闭包），
			之后标记了的变量都是要回收的。
			该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始扫描内存中的对象。
			凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
		引用计数：引用计数就是跟踪每个变量被引用的次数。当声明了一个变量并将一个引用类型赋值给它时引用次数就是1.
			当这个引用次数变为0时就回收内存。引用计数可能造成内存泄漏，因为循环引用变量。
	造成内存泄漏的情况：
		1. 意外的全局变量，
			普通形式定义了一个全部变量，没有用var。
			this点了一个未被定义的变量。
			与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用，
				高内存消耗导致缓存突破上限，因为缓 存内容无法被回收。
			解决方法：如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。
		2.被遗忘的计时器或者回调函数
		3.脱离Dom的引用
		4.不合理使用闭包（有人说闭包不会造成内存泄漏，只是原始IE浏览器垃圾回收写的bug，只有程序写的不对才会造成内存泄漏）
js运行机制：
	基本知识点：
		1. js是单线程的，js作为浏览器脚本语言，它的主要用途是与用户互动，以及操作DOM，因此js是单线程，
			也避免了同时操作同一个DOM的矛盾问题；
		2. 事件循环：js引擎存在monitoring process（有道翻译：监控进程）进程，会持续不断的检查主线程执行栈是否为空，一旦为空，
			就会去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制
			又称为Event Loop（事件循环）
		3. 执行栈：所有同步任务都在主线程上执行，形成一个执行栈
		4. 如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行；
	同步任务和异步任务：
		同步任务(synchronous)：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
		异步任务(asynchronous)：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通
			知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
	宏观任务和微任务:
		注意点：这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务
		宏任务(macro-task)：整体代码script、setTimeOut、setInterval
		微任务(mincro-task)：promise.then、promise.nextTick(node)、ajax，Promise.then、MutaionObserver、
			process.nextTick(Node.js 环境)，async/await实际上是promise+generator的语法糖，也就是promise，也就是微观任务
	eventLoop事件循环
		1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
		2. 同步任务会直接进入主线程依次执行；
		3. 异步任务会再分为宏任务和微任务；
		4. 宏任务进入到Event Table（事件表）中，并在里面注册回调函数，
			每当指定的事件完成时，Event Table会将这个函数移到Event Queue（事件队列）中；
		5. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，
			Event Table会将这个函数移到Event Queue中；
		6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；
		7. 上述过程会不断重复，这就是Event Loop事件循环
闭包:
	什么是闭包?闭包就是能够读取其他函数内部变量的函数，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包
	闭包用途：读取局部变量，缓存数据
	注意点:
		1. 闭包会缓存数据，会影响性能，在IE中可能会造成内存泄漏，所以不能滥用闭包
		2. 闭包会在父函数外部，改变父函数内部变量的值
	闭包为什么可以实现在函数外读取到函数内的变量？
		f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，
		因此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。
	应用场景: 
		1. 将一个函数作为另一个函数的返回值
		2. 将函数作为实参传递给另一个函数调用。
递归：
	什么是递归：
		1. 在程序中间接或者直接调用自己
		2. 跳出结构，才有结果
		3. 一定要有结束条件
	递归的条件：
		1. 一定要有结束的条件
		2. 子问题和原始问题为同样的事情
	递归的技巧
		1. 假设递归函数已经写好
		2. 寻找地递推关系
		3. 将递推关系转换为递归体
		4. 将临界条件加入到递归体中
数据类型：
	基本数据类型：String、Number、Undefined、Boolean、null、symbol
	复杂类型： Object
深拷贝和浅拷贝：
	深拷贝：
		把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中
		实现方式：
		1. Json.parse(Json.stringify(arr))，可以实现数组或对象深拷贝，但不能处理函数、手写递归的方法
		2. 手写递归的方法
	浅拷贝：
		只是复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存
instanceof 原理
	只要右边变量的prototype在左边的原型链上即可，因此，instanceof 在查找的过程中会遍历左边变量的原型链，
	直到找到右边变量的 prototype，如果查找失败，则会返回 false
防抖和节流：
	防抖：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，
		如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
	节流：如果短时间内持续触发同一件事情，那么函数执行一次后，该函数在指定的时间内不在工作
防抖和节流的区别：
	 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，
	 而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，
	 每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。
栈和堆：
	栈：会自动分配内存，会自动释放，存放基本数据类型，还会存放引用数据类型的指针。
		栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单存储。
			基本类型在当前执行环境结束时销毁
	堆：动态分配内存，大小不定也不会自动释放。堆内存存储的对象类型数据对于大小这方面，一般都是未知的
		堆对应js中存储的内容何时销毁：
			引用类型不会随执行环境结束而销毁，只有当所有引用它的变量不存在时这个对象才被垃圾回收机制回收。
箭头函数和普通函数的区别：
	1. 写法不一致
	2. 箭头函数是匿名函数，不能作为构造函数，不能使用new
	3. 箭头函数不绑定arguments，取而代之用rest参数...解决
	4. 箭头函数的this永远指向其上下文的this，没有办改变其指向，普通函数的this指向调用它的对象
	5. 箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响
字符串转数组，对象转字符串：
	字符串转数组：str.split('-')
	数组转字符串：arr.join('-')
	对象转字符串：JSON.string('')
	对象转数组：Array.from(obj);
		1.object中必须有length属性，返回的数组长度取决于length长度
        2.key 值必须是数值
	Object.keys()和Object.values()，Object.entries()都是ES6新增的数组方法，用于遍历，返回的都是数组
原生js绑定事件的方式:
	1. <button onclick='事件处理函数''>点我 </button>
	2.  对象.on事件名字=事件处理函数 =>解绑：xxx.on事件类型 = null
	3. addEventListener：
		a)addEventListener(事件类型，事件处理函数，Boolean) IE8不支持。谷歌火狐支持
          this是当前绑定事件的元素
		b)解绑：removeEvenetListener(事件类型, 函数名字，Boolean)
	4. attachEvent;
		attachEvent(有on的事件类型，事件处理函数)谷歌火狐不支持，IE8支持
		解绑：detachEvent(on的事件类型， 函数名字)
	绑定多个事件的兼容性代码：
	function removeEvenetListener(ele, type, fn) {
      if (ele.removeEvenetListener) {
        return removeEvenetListener(type, fn, false)
      } else if (ele.detachEvent) {
        return ele.detachEvent('on' + type, fn)
      } else {
        ele['on' + type] = null
      }
    } 
promise:是一个构造函数，用来生成promise实例
	1. Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
		它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
		a) resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”
		b)reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），
			在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
	2. Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
	3. then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，
		第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。
		这两个函数都接受Promise对象传出的值作为参数。
			a)then方法是定义在原型对象上的即Promise.prototype上的，then方法返回的是一个新的Promise实例
	4. catch是发生错误时的回调，catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。
	5. finally方法是不管Promise对象是成功还是失败，都会调用这个方法
	6. all方法：Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例，
		Promise.all()方法接受一个数组作为参数，，如果不是，就会先调用下面讲到的Promise.resolve方法，
		将参数转为 Promise 实例，再进一步处理。
		另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例
		a)如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。
		b)promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，
			或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。
		c)Promise.all 可以多个promise请求并发，但是有个缺点，
			就是其中一个请求挂掉的话，就不会执行then方法，也就是说，一个挂掉等于全部挂掉，
	7. Promise.resolve() 
		a) 有时需要将现有对象转为 Promise 对象，
		b)resolve()是用来表示promise的状态为fullfilled，相当于只是定义了一个有状态的Promise，但是并没有调用它；
			promise调用then的前提是promise的状态为fullfilled；只有promise调用then的时候，then里面的函数才会被推入微任务中；
		c)参数
			参数时一个promise实例:不做任何修改，原封不动的返回.
			参数是一个thenable对象，thenable对象指的是具有then方法的对象，
				会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
			参数不是具有then方法的对象，或根本就不是对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。
			不带有任何参数:Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。
	8. Promise.reject() 
		a) Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数
	9. Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
undefined和notundefined的区别:
	Undefind是js的一种数据类型；not defined遇到没有定义的变量但是使用了，是一种错误
undefined和null的区别:
	1. null:表示没有对象，即该处不该有值；作为函数的参数，表示函数的参数不是对象,作为原型链对象的终点.
		类型的值只有一个，就是null
		null这个值专门用来表示一个为空的对象
		使用typeof检查一个null值时，会返回object
	2. undefined表示缺少值，此时应该有值但是还没有被赋值
		变量被声明了，没有赋值
		调用函数应提供的参数没有提供对象没有赋值的属性
		函数没有返回值时默认返回undefined
es6的新特性：
	数组的方法
		Array.from() 将伪数组或者类似数组的对象（只要有length属性）转化为真正的数组
		Array.of(), 将一组数值转为数组 Array.of(1, 2, 3) => [1, 2, 3]
		find() /findIndex()
		fill()，使用给定值，填充数组
			i.	参数1：需要填充的值
			ii.	参数2（可选）：从什么位置开始
			iii.	参数3（可选）：从什么位置结束
		Includes()返回一个布尔值，数组是否包含某个值
		entries()/keys()/values();用于遍历数组
		flat()/flatMap()
	数组去重的方法
		[…new Set(array)]
		new Set([…])结合Array.from（）
		let arr = [x, b, c…] let unique = […new Set(arr)]
	Strng（字符串）
		Includes(val)：返回布尔值，是否找到了参数字符串
		startsWith(val)：返回布尔值，是否以某字符开头
		endsWith(val)：返回布尔值，是否以某字符结尾
		trimStart/trimEnd：消除头部和尾部的空格，返回新字符串，不会修改原字符串
		padStart/padEnd
			padStart:用于头部补全，padEnd: 用于尾部补全
				参数1：字符串补全生效的最大长度；参数2：用于补全的字符串
					‘x’.padStart(5, ‘ab’) => ababx; ‘x’.padStart(4, ‘ab’) => abax;
		repeat(val)：表示将某个字符重复几遍，返回新字符串；’x’.repeat(3) => ‘xxx’
	对象的方法
		let arr = [x, b, c…] let unique = […new Set(arr)]
		Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象，浅拷贝
		Object.keys()，Object.values()，Object.entries() 都是遍历，返回的都是数组
	set
		操作方法
			add（val）添加某个值，返回Set结构本身
			delete(val)删除一个值，返回布尔值，是否删除成功
			has(val)返回布尔值，表示该值是否为set的成员
			clear()清除所有成员，无返回值
		遍历方法
			1. .keys()返回键名的遍历器
			2. .values()
			3. .entries()
			4. .forEach()方法出第一个回调函数参数除外，可有第二个参数，表示绑定处理函数内部的this对象
	Map，类似对象，也是键值对的集合
		操作方法:
			1. add（key，value）设置key对应的键值为value，然后返回整个map结构，如果key已经有值，键值会被更新
			2. get（）get方法读取key对应的键值，如果找不到key，返回undefined
			3. has(key)返回一个布尔值，表示某个键是否在当前 Map 对象之中
			4. delete,delete方法删除某个键，返回布尔值
			5.clear()清除所有成员，没有返回值
		遍历方法
			1. .keys()返回键名的遍历器。
			2. .values()返回键值的遍历器
			3. .entries()返回所有成员的遍历器
			4. forEach()遍历 Map 的所有成员
		map转数组:[...map]
		数组转map:数组转map，将数组传入map构造函数
		对象转Map:
			let obj = {"a":1, "b":2};
			let map = new Map(Object.entries(obj));
字符串的方法ES5
	slice(开始的索引,结束的索引)：提取字符串，不包含结束索引
	substr(开始的位置,个数);返回的是截取后的新的字符串
	substring(开始的索引,结束的索引),返回截取后的字符串,不包含结束的索引的字符串
	split("要干掉的字符串",切割后留下的个数（可选）);切割字符串
	trim();干掉字符串两端的空格
	indexOf(要找的字符串,从某个位置开始的索引);返回的是这个字符串的索引值,没找到则返回-1
	concat(字符串1,字符串2,...);返回的是拼接之后的新的字符串
	charAt(索引),返回值是指定索引位置的字符串,超出索引,结果是空字符串
.concat(数组,数组,数组,...) 组合一个新的数组
.every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，
第二个参数是索引值,第三个参数是原来的数组(没用)，如果这个数组中的每个元素的值都符合条件,最后才返回的是true
.filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
.push(值);
.pop()
.unshift();--->向数组的第一个元素前面插入一个新的元素,
数组ES5
	.concat(数组,数组,数组,...) 组合一个新的数组
	.every(函数)--返回值是布尔类型,函数作为参数使用,函数中有三个参数,第一个参数是元素的值，
		第二个参数是索引值,第三个参数是原来的数组(没用)，如果这个数组中的每个元素的值都符合条件,最后才返回的是true
	.filter(函数);返回的是数组中每一个元素都复合条件的元素,组成了一个新的数组
	.push(值);
	.pop()
	.unshift();--->向数组的第一个元素前面插入一个新的元素,
	.shift();--->删除数组中第一个元素,返回值就是删除的这个值
	.forEach(函数)方法
	.indexOf(元素值);返回的是索引,没有则是-1
	.map(函数);--->数组中的每个元素都要执行这个函数,把执行后的结果重新的全部的放在一个新的数组中
	.slice(开始的索引,结束的索引);把截取的数组的值放在一个新的数组中,但是不包含结束的索引对应的元素值
	.splice(开始的位置,要删除的个数,替换的元素的值);一般是用于删除数组中的元素,或者是替换元素,或者是插入元素

mvvm和jquery的区别:
	jquery: jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，
		其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。
		比如需要获取label标签的内容：$("lable").val();,它还是依赖DOM元素的值。 
	mvvm框架以vue举例:
		Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，
			可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。

	mvvm(模型-视图-视图模型)解释:
		M：model/v:view/vm:viewModel
		一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。
		二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。
		这两个方向都实现的，我们称之为数据的双向绑定。
		总结：
			在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，
			当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，
			ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。
			并且MVVM中的View 和 ViewModel可以互相通信。
	
ajax的优缺点:
	优点：
		前后端负载平衡
		无刷新更新数据
		异步与服务通信
		基于标准被广泛支持
		界面与应用分离
	缺点
		AJAX干掉了Back和History功能，即对浏览器机制的破坏。
		AJAX的安全问题。
		对搜索引擎支持较弱
前端渲染和后端渲染
	后端渲染：
		服务器拿到页面url， 先解析url，判断是什么页面，通过一种技术（jsp或者其他）直接把html、css、
			Java代码或者其他后端语言（从数据库请求数据然后渲染到页面）渲染成最终在浏览器展示的页面（html+css），
			然后返回给客户端进行展示
		优点：前端耗时少，即减少了首屏时间，模板统一在后端。前端（相对）省事，不占用客户端运算资源（解析模板）
		缺点：
			占用服务器资源
			页面有后端编写和维护
			前端要开发页面，需要通过PHP或者Java语言来编写页面代码
			html和数据及相应逻辑混在一起，编写维护成本高
	后端路由：
		后端处理URL和页面之间的映射关系
	前端渲染：浏览器中显示的网页中的大部分内容，都是由前端写的 js 代码在浏览器中执行，
		最终渲染出来的网页，即后端返回JSON数据，前端利用预先写的html模板，循环读取JSON数据，拼接字符串，并插入页面。
		步骤：
			步骤：浏览器输入地址，从静态资源服务器拿到相应的js+html+css返回到浏览器，html和css浏览器直接可以渲染。
				js浏览器执行，发起ajax请求后，从有API服务器的服务器请求数据拿到数据，然后通过js将拿到的数据渲染到页面上
		优点：分散服务端渲染时间到浏览器端，提高可维护性
		缺点：首页会有白屏、seo
	单页面富应用（SPA）：静态资源服务器可能只有一个html+css+js；步骤：浏览器输入地址，将html+css+js全部资源下载到浏览器；
		通过前端路由，前端路由通过一些js代码的判断从已经下载的全部资源中获取相关资源，放到相应组件上展示
	前端路由：浏览器上的url和全部资源中的映射关系
浏览浏览器的工作原理：
	1. 浏览器由多个进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，
		每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。
		a)进程：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，
			一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。
		b)线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。
			一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。
		c)进程和线程的基本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
	2. 浏览器的组成
		1）用户界面。包括地址栏、后退/前进按钮、书签目录等。
		2）浏览器引擎 － 用来查询及操作渲染引擎的接口。
		3）渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。
		4）网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。
		5）UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
		6）JS解释器 － 用来解释执行JS代码。
		7）数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，
			这是一种轻量级完整的客户端存储技术
	3. 浏览器渲染过程：
		1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js,在DOM树中每一个HTML标签都有一个对应的节点，
			并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。
		2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。
			解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。
		3.DOM Tree + CSSOM --> 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。
			DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。
			而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。
		4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。
浏览器的重绘和重排（区别）
	重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算
		元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。
	重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，
		浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。
		这个过程叫做重绘。 由此我们可以看出，重绘不一定导致回流，回流一定会导致重绘。
	单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分
	重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，
	一般我们宁可选择代价更小的重绘。
	『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。
如何触发重排和重绘？任何改变用来构建渲染树的信息都会导致一次重排或重绘：
	1.添加、删除、更新DOM节点
	2.通过display: none隐藏一个DOM节点-触发重排和重绘
	3.通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
	4.移动或者给页面中的DOM节点添加动画
	5.添加一个样式表，调整样式属性
	6.用户行为，例如调整窗口大小，改变字号，或者滚动。
如何避免重绘或者重排？
	1.集中改变样式
	2.使用DocumentFragment，创建游离与dom树之外的节点，然后在此节点上操作，最后插入到dom树种
游览器输入一个地址。到页面展示中间经历了哪些东西？
	1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；
		如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL
	2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
	3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。
	4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
	5. 握手成功后，浏览器向服务器发送http请求，请求数据包。
	6. 服务器处理收到的请求，将数据返回至浏览器
	7. 浏览器收到HTTP响应
	8. 读取页面内容，浏览器渲染，解析html源码
	9. 生成Dom树、解析css样式、js交互
	10. 客户端和服务器交互
	11. ajax查询
TCP是属于网络分层中的传输层:
	第一次握手,首先客户端向服务器端发送一段TCP报文， 标记位为SYN，表示“请求建立新连接”;序号为Seq=X（X一般为1）
	第二次握手：服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文：
		标志位为SYN（发起一个新连接。）和ACK（确认序号有效。）表示“确认客户端的报文Seq序号有效，
		服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；
	第三次握手：客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，
		结束SYN-SENT阶段。并返回最后一段TCP报文。其中：
		标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；
		序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；
		确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；
		随后客户端进入ESTABLISHED阶段。
200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
302：重定向
400   （错误请求） 服务器不理解请求的语法
401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
http状态码
	200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
	302：重定向
	400   （错误请求） 服务器不理解请求的语法
	401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
	404   （未找到） 服务器找不到请求的网页。
	500   （服务器内部错误）  服务器遇到错误，无法完成请求。 
	502：无效的相应
	504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。  
get、post的区别：
	1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，
		get把请求的数据在URL后通过？连接，通过&进行参数分割。psot将参数存放在HTTP的包体内
	2. get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制
	3. get后退不会有影响，post后退会重新进行提交
	4. get请求可以被缓存，post不可以被缓存
	5. get请求只URL编码，post支持多种编码方式
	6.get请求的记录会留在历史记录中，post请求不会留在历史记录
	7.get只支持ASCII字符，post没有字符类型限制
http和https的区别：
	1. https有ca（电子商务认证授权机构）证书，http一般没有
	2. http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议
	3. http默认80端口，https默认443端口。

轮询：说白了就是客户端定时去请求服务端，  是客户端主动请求来促使数据更新；
长轮询：说白了也是客户端请求服务端，但是服务端并不是即时返回，而是当有内容更新的时候才返回内容给客户端，
	从流程上讲，可以理解为服务器向客户端推送内容；
轮询和长轮询的区别：
	轮询：
　　1：大量耗费服务器内存和宽带资源，因为不停的请求服务器，很多时候 并没有新的数据更新，因此绝大部分请求都是无效请求
　　2：数据不一定是实时更新，要看设定的请求间隔，基本会有延迟。
长轮询：
　　1：解决了轮询的两个大问题，数据实时更新；
　　2：唯一的缺点是服务器在挂起的时候比较耗内存；


